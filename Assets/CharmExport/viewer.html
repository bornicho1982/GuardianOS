<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destiny 2 - Charm Armor Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Segoe UI', sans-serif;
            color: #fff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        #info h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            color: #7dd3fc;
        }

        #info p {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        #loading .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #7dd3fc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(125, 211, 252, 0.3);
            border-color: #7dd3fc;
        }

        .btn.active {
            background: rgba(125, 211, 252, 0.5);
            border-color: #7dd3fc;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="info">
        <h1 id="char-class">üõ°Ô∏è Character</h1>
        <p id="char-light">Exported from GuardianOS</p>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading armor pieces...</p>
    </div>

    <div id="controls">
        <button class="btn active" data-piece="all">All</button>
        <button class="btn" data-piece="mask">Mask</button>
        <button class="btn" data-piece="grasps">Grasps</button>
        <button class="btn" data-piece="vest">Vest</button>
        <button class="btn" data-piece="strides">Strides</button>
        <button class="btn" data-piece="cloak">Cloak</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.3/umd/index.min.js"></script>

    <script>
        // Scene setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.2, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1, 0);

        // Lighting - Studio setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
        keyLight.position.set(5, 5, 5);
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0x8888ff, 0.5);
        fillLight.position.set(-5, 3, -5);
        scene.add(fillLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
        rimLight.position.set(0, 5, -5);
        scene.add(rimLight);

        // Environment for reflections
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        // Create a simple environment
        const envScene = new THREE.Scene();
        envScene.background = new THREE.Color(0x1a1a2e);
        const envTexture = pmremGenerator.fromScene(envScene).texture;
        scene.environment = envTexture;

        // Floor grid
        const gridHelper = new THREE.GridHelper(10, 20, 0x444466, 0x222244);
        scene.add(gridHelper);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const fbxLoader = new THREE.FBXLoader();

        // Armor pieces storage
        const armorPieces = {};
        const basePath = '';
        const texturesPath = 'Textures/';

        // Character data from GuardianOS export
        let characterData = null;
        // Store materials globally
        window.characterMaterials = null;

        // Texture prefixes for each gender
        const TEXTURE_PREFIXES = {
            Male: {
                mask: '7C45F980',
                grasps: '241FF880',
                vest: '6A1FF880',
                strides: '481FF880',
                cloak: '1C71F880'
            },
            Female: {
                mask: '8C45F980',
                grasps: '3D1FF880',
                vest: '085CF980',
                strides: 'A9B5F880',
                cloak: 'F870F880'
            }
        };

        // Current gender (will be loaded from JSON)
        let currentGender = 'Female';

        // Get armor pieces based on gender
        function getPieces(gender) {
            const prefixes = TEXTURE_PREFIXES[gender] || TEXTURE_PREFIXES.Male;
            return [
                { name: 'mask', file: 'Last Discipline Mask.fbx', texPrefix: prefixes.mask },
                { name: 'grasps', file: 'Last Discipline Grasps.fbx', texPrefix: prefixes.grasps },
                { name: 'vest', file: 'Last Discipline Vest.fbx', texPrefix: prefixes.vest },
                { name: 'strides', file: 'Last Discipline Strides.fbx', texPrefix: prefixes.strides },
                { name: 'cloak', file: 'Last Discipline Cloak.fbx', texPrefix: prefixes.cloak }
            ];
        }

        // Load character data from GuardianOS export
        async function loadCharacterData() {
            try {
                const response = await fetch('character_data.json');
                const data = await response.json();
                characterData = data;
                window.characterMaterials = data.materials;

                // 1. CRITICAL: Set Gender FIRST before any UI updates can crash
                if (data.character && data.character.gender) {
                    currentGender = data.character.gender;
                    console.log(`[Viewer] Set gender to ${currentGender}`);
                } else {
                    console.warn('[Viewer] No gender found in JSON, using default');
                }

                console.log('[Viewer] Materials loaded:', data.materials ? Object.keys(data.materials).length : 0);

                // 2. Update UI Info (Safe)
                const elClass = document.getElementById('char-class');
                const elLight = document.getElementById('char-light');

                if (elClass) elClass.textContent = `üõ°Ô∏è ${data.character.className} ${data.character.race}`;
                if (elLight) elLight.textContent = `‚ú¶ ${data.character.light} ¬∑ Exported from GuardianOS`;

                console.log('[Viewer] Character data loaded successfully');
            } catch (error) {
                console.error('[Viewer] Error loading character data:', error);
                document.getElementById('info').innerHTML += '<br><span style="color:red">Error loading data</span>';
            }
        }

        let loadedCount = 0;

        // Load textures for a piece
        function loadTextures(prefix) {
            const textures = {};

            // Albedo (diffuse color)
            textures.base = textureLoader.load(basePath + texturesPath + prefix + '_albedo.png');
            textures.base.encoding = THREE.sRGBEncoding;
            textures.base.flipY = true;

            // Normal map
            textures.normal = textureLoader.load(basePath + texturesPath + prefix + '_normal.png');
            textures.normal.flipY = true;

            // GStack (combined PBR: R=AO, G=Roughness, B=Metalness)
            textures.gstack = textureLoader.load(basePath + texturesPath + prefix + '_gstack.png');
            textures.gstack.flipY = true;

            // Dyemap (color zones: R=Primary, G=Secondary, B=Worn/Tertiary)
            textures.dyemap = textureLoader.load(basePath + texturesPath + prefix + '_dyemap.png');
            textures.dyemap.flipY = true;

            return textures;
        }

        // Standard Bungie Shader Colors (Fallback Default: Blue/White)
        const SHADER_COLORS = {
            primary: new THREE.Color(0x324c6b),   // Blue
            secondary: new THREE.Color(0xebebeb), // White/Silver
            worn: new THREE.Color(0x282828)       // Dark Grey
        };

        // Map internal viewer piece names to API JSON keys
        const PIECE_TO_API_MAP = {
            'mask': 'helmet',
            'grasps': 'arms',
            'vest': 'chest',
            'strides': 'legs',
            'cloak': 'classItem'
        };

        // Create PBR material with dye coloring
        function createCharmMaterial(textures, pieceName) {
            const material = new THREE.MeshStandardMaterial({
                map: textures.base,
                normalMap: textures.normal,
                normalScale: new THREE.Vector2(1, 1),
                roughness: 0.7,
                metalness: 0.5,
                envMapIntensity: 1.2
            });

            // Use gstack for PBR properties
            if (textures.gstack) {
                material.roughnessMap = textures.gstack;
                material.metalnessMap = textures.gstack;
                material.aoMap = textures.gstack;
            }

            // Determine Colors (Dynamic or Default)
            let colorPrimary = SHADER_COLORS.primary;
            let colorSecondary = SHADER_COLORS.secondary;
            let colorWorn = SHADER_COLORS.worn;

            if (window.characterMaterials && pieceName) {
                const apiKey = PIECE_TO_API_MAP[pieceName];
                const shaderDef = window.characterMaterials[apiKey];

                if (shaderDef && shaderDef.Colors) {
                    console.log(`[Material] Found shader definition for ${pieceName} (${apiKey})`);

                    const findColor = (channel) => {
                        const c = shaderDef.Colors.find(x => x.ChannelName === channel);
                        return c ? new THREE.Color(c.HexColor) : null;
                    };

                    // Bungie mapping hypothesis (Refined):
                    // Primary Channel (Blue in UI?) -> Applied to Main Armor
                    // Secondary Channel -> Applied to details
                    // Tertiary -> Applied to fabric/worn bits
                    // Note: This mapping might need tweaking per shader "arrangement" logic which is complex

                    const p = findColor("Primary");
                    const s = findColor("Secondary");
                    const t = findColor("Tertiary");

                    if (p) colorPrimary = p;
                    if (s) colorSecondary = s;
                    if (t) colorWorn = t;
                }
            }

            // Store textures for shader injection
            material.userData.dyeMap = { value: textures.dyemap };
            material.userData.dyePrimary = { value: colorPrimary };
            material.userData.dyeSecondary = { value: colorSecondary };
            material.userData.dyeWorn = { value: colorWorn };

            // Custom shader to apply dye colors
            material.onBeforeCompile = (shader) => {
                // Add uniforms
                shader.uniforms.dyeMap = material.userData.dyeMap;
                shader.uniforms.dyePrimary = material.userData.dyePrimary;
                shader.uniforms.dyeSecondary = material.userData.dyeSecondary;
                shader.uniforms.dyeWorn = material.userData.dyeWorn;

                // Add uniform declarations
                shader.fragmentShader = `
                    uniform sampler2D dyeMap;
                    uniform vec3 dyePrimary;
                    uniform vec3 dyeSecondary;
                    uniform vec3 dyeWorn;
                ` + shader.fragmentShader;

                // Inject dye coloring after map_fragment
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <map_fragment>',
                    `
                    #include <map_fragment>
                    
                    // Apply dye colors based on dyemap channels
                    #ifdef USE_MAP
                        vec4 dyeMask = texture2D(dyeMap, vUv);
                        
                        // Destiny Dyemaps: R=Primary, G=Secondary, B=Tertiary, A=Worn
                        // We use a simple mix to tint the base albedo.
                        
                        vec3 finalColor = diffuseColor.rgb;
                        
                        // Tint Mapping (Additive/Mix)
                        // If mask.r is 1.0, we want the Primary Color to dominate but respect Albedo details.
                        
                        finalColor = mix(finalColor, dyePrimary, dyeMask.r);
                        finalColor = mix(finalColor, dyeSecondary, dyeMask.g);
                        finalColor = mix(finalColor, dyeWorn, dyeMask.b);
                         
                        // FORCE SOLID OPACITY (Fixes Ghosting)
                        diffuseColor = vec4(finalColor, 1.0); 
                    #endif
                    `
                );

                console.log('[Shader] Dye coloring injected');
            };

            return material;
        }

        // FBX Files (Dynamic from JSON)
        function getPiecesFromData(data) {
            if (!data || !data.armor) return [];

            // Map keys to readable piece names
            const map = [
                { key: 'helmet', name: 'mask' },
                { key: 'arms', name: 'grasps' },
                { key: 'chest', name: 'vest' },
                { key: 'legs', name: 'strides' },
                { key: 'classItem', name: 'cloak' }
            ];

            return map.map(m => {
                const item = data.armor[m.key];
                // Use imported modelFile if available, else fallback provided (or skip)
                const file = item && item.modelFile ? item.modelFile : null; // Expect filename only
                return {
                    name: m.name,
                    file: file,
                    key: m.key // API key for materials lookup
                };
            }).filter(p => p.file); // Only return pieces with files
        }

        // Cache loaded textures to avoid re-fetching
        const textureCache = {};

        function getTextureSet(prefix) {
            if (textureCache[prefix]) return textureCache[prefix];

            // The existing loadTextures function already handles flipY and encoding for each texture.
            // No need for an internal loadTex helper here.
            const data = loadTextures(prefix); // Use existing helper
            textureCache[prefix] = data;
            return data;
        }

        // Load all armor pieces
        function loadArmor() {
            if (!characterData) return;
            const pieces = getPiecesFromData(characterData);
            console.log(`[Viewer] Loading ${currentGender} armor pieces...`);

            pieces.forEach(piece => {
                console.log(`[Viewer] Loading piece: ${piece.name} -> ${piece.file}`);

                fbxLoader.load(
                    basePath + piece.file,
                    (fbx) => {
                        // Scale and rotate FBX
                        fbx.scale.setScalar(1.0);
                        fbx.rotation.x = -Math.PI / 2; // Rotate -90 deg on X to stand upright

                        // Traverse meshes
                        fbx.traverse((child) => {
                            if (child.isMesh) {
                                // Extract prefix from mesh name (e.g. "8C45F980_Masculine_...")
                                const parts = child.name.split('_');
                                let prefix = null;
                                // Hex prefix is usually 8 chars at start
                                if (parts.length > 0 && parts[0].length === 8) {
                                    prefix = parts[0];
                                }

                                // GENDER FILTER: Hide wrong gender
                                // Names are like "8C45F980_Masculine_Group..."
                                if (child.name.includes("Masculine") && currentGender === "Female") {
                                    child.visible = false;
                                    return;
                                }
                                if (child.name.includes("Feminine") && currentGender === "Male") {
                                    child.visible = false;
                                    return;
                                }

                                if (prefix) {
                                    // Load textures for this specific mesh!
                                    const textures = getTextureSet(prefix);

                                    // Make material unique per mesh to avoid conflicts
                                    const material = createCharmMaterial(textures, piece.name);

                                    // Force Opaque and DoubleSide to fix ghosting & visibility
                                    material.transparent = false;
                                    material.opacity = 1.0;
                                    material.alphaTest = 0.5; // Discard fully transparent pixels if any
                                    material.side = THREE.DoubleSide;

                                    child.material = material;
                                    child.castShadow = true;
                                    child.receiveShadow = true;

                                    console.log(`  ‚úì Mesh: ${child.name} -> Applied Prefix ${prefix}`);
                                } else {
                                    console.warn(`  ? Mesh: ${child.name} (No prefix found)`);
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0x888888,
                                        side: THREE.DoubleSide,
                                        transparent: false,
                                        opacity: 1.0
                                    });
                                }

                                // Show all meshes (removed threshold)
                                child.visible = true;
                            }
                        });

                        scene.add(fbx);
                        armorPieces[piece.name] = fbx;

                        // Update UI Toggle State (if needed)
                    },
                    (xhr) => {
                        // Progress
                        const percent = xhr.loaded / xhr.total * 100;
                        if (percent >= 100) {
                            // document.getElementById('loading').style.display = 'none';
                        }
                    },
                    (error) => {
                        console.error(`[Viewer] Error loading ${piece.name}:`, error);
                    }
                );
            });

            // Hide loading overlay after a timeout (fallback)
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 2000);
        }

        // Button controls
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const piece = btn.dataset.piece;

                Object.keys(armorPieces).forEach(key => {
                    if (armorPieces[key]) {
                        armorPieces[key].visible = (piece === 'all' || piece === key);
                    }
                });
            });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize - Load character data first, then armor
        async function init() {
            await loadCharacterData();
            loadArmor();
            animate();
        }

        // Start
        init();
    </script>
</body>

</html>